from _typeshed import Incomplete
from enum import IntEnum
from typing import Generic, TypeVar, overload

def __getattr__(name: str, /) -> Incomplete: ...

class State(IntEnum):
    S0 = 0
    S1 = 1
    Sx = 2 # undefined value or conflict
    Sz = 3 # high-impedance / not-connected
    Sa = 4 # don't care (used only in cases, /)
    Sm = 5 # marker (used internally by some passes, /)

class SyncType(IntEnum):
    ST0 = 0 # level sensitive: 0
    ST1 = 1 # level sensitive: 1
    STp = 2 # edge sensitive: posedge
    STn = 3 # edge sensitive: negedge
    STe = 4 # edge sensitive: both edges
    STa = 5 # always active
    STg = 6 # global clock
    STi = 7 # init

class ConstFlags(IntEnum):
    CONST_FLAG_NONE = 0
    CONST_FLAG_STRING = 1
    CONST_FLAG_SIGNED = 2 # only used for parameters
    CONST_FLAG_REAL = 4 # only used for parameters

SigSig = tuple[SigSpec, SigSpec]

class IdString:
    index_: int

    @overload
    def __init__(self, /) -> None: ...
    @overload
    def __init__(self, str: str | IdString, /) -> None: ...
    def __del__(self, /) -> None: ...

    def __lt__(self, rhs: IdString, /) -> bool: ...
    def __eq__(self, rhs: IdString | str, /) -> bool: ...
    def __ne__(self, rhs: IdString | str, /) -> bool: ...

    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def __str__(self, /) -> str: ...

    def c_str(self, /) -> str: ...
    def str(self, /) -> str: ...

    def isPublic(self, /) -> bool: ...

    def __getattr__(self, name: str, /) -> Incomplete: ...

def escape_id(str: str, /) -> str: ...

def unescape_id(str: str | IdString, /) -> str: ...

def id2cstr(str: IdString, /) -> str: ...

def encode_filename(filename: str, /) -> str: ...

class Const:
    flags: int

    @overload
    def __init__(self, /) -> None: ...
    @overload
    def __init__(self, str: str, /) -> None: ...
    @overload
    def __init__(self, bit: State, width: int, /) -> None: ...
    @overload
    def __init__(self, bits: list[State], /) -> None: ...
    @overload
    def __init__(self, other: Const, /) -> None: ...
    def __del__(self, /) -> None: ...

    def __lt__(self, other: Const, /) -> bool: ...
    def __eq__(self, other: Const, /) -> bool: ...
    def __ne__(self, other: Const, /) -> bool: ...

    def bits(self, /) -> list[State]: ...
    def as_bool(self, /) -> bool: ...
    def as_int(self, is_signed: bool = False, /) -> int: ...
    def as_string(self, any: str, /) -> str: ...
    @classmethod
    def from_string(cls, str: str, /) -> Const: ...
    def to_bits(self, /) -> list[State]: ...

    def decode_string(self, /) -> str: ...
    def size(self, /) -> int: ...
    def empty(self, /) -> bool: ...
    def bitvectorize(self, /) -> None: ...

    def is_fully_zero(self, /) -> bool: ...
    def is_fully_ones(self, /) -> bool: ...
    def is_fully_def(self, /) -> bool: ...
    def is_fully_undef(self, /) -> bool: ...
    def is_fully_undef_x_only(self, /) -> bool: ...
    def is_onehot(self, pos=None, /) -> bool: ...

    def extract(self, offset: int, len: int = 1, padding: State = State.S0, /) -> Const: ...

    def get_min_size(self, is_signed: bool, /) -> int: ...

    def compress(self, is_signed: bool = False, /) -> None: ...

    def extu(self, width: int, /) -> None: ...
    def exts(self, width: int, /) -> None: ...

    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def __getattr__(self, name: str, /) -> Incomplete: ...

class AttrObject:
    attributes: dict[IdString, Const]

    def has_attribute(self, id: IdString, /) -> bool: ...

    def set_bool_attribute(self, id: IdString, value: bool = True, /) -> None: ...
    def get_bool_attribute(self, id: IdString, /) -> bool: ...

    def get_blackbox_attribute(self, ignore_wb: bool = False, /) -> bool: ...

    def set_string_attribute(self, id: IdString, value: str, /) -> None: ...
    def get_string_attribute(self, id: IdString, /) -> str: ...

    def set_strpool_attribute(self, id: IdString, data: list[str], /) -> None: ...
    def add_strpool_attribute(self, id: IdString, data: list[str], /) -> None: ...
    def get_strpool_attribute(self, id: IdString, /) -> list[str]: ...

    def set_src_attribute(self, src: str, /) -> None: ...
    def get_src_attribute(self, /) -> str: ...

    def set_hdlname_attribute(self, hierarchy: list[str], /) -> None: ...
    def get_hdlname_attribute(self, /) -> list[str]: ...

    def set_intvec_attribute(self, id: IdString, data: list[int], /) -> None: ...
    def get_intvec_attribute(self, id: IdString, /) -> list[int]: ...

class SigChunk:
    wire: Wire
    data: list[State]
    width: int
    offset: int

    @overload
    def __init__(self, /) -> None: ...
    @overload
    def __init__(self, value: Const, /) -> None: ...
    @overload
    def __init__(self, wire: Wire, offset: int = ..., width: int = 1, /) -> None: ...
    @overload
    def __init__(self, str: str, /) -> None: ...
    @overload
    def __init__(self, val: int, width: int = 32, /) -> None: ...
    @overload
    def __init__(self, bit: State, width: int = 1, /) -> None: ...
    @overload
    def __init__(self, bit: SigBit, /) -> None: ...

    def extract(self, offset: int, length: int, /) -> SigChunk: ...
    def size(self, /) -> int: ...
    def is_wire(self, /) -> bool: ...

    def __lt__(self, other: SigChunk, /) -> bool: ...
    def __eq__(self, other: SigChunk, /) -> bool: ...
    def __ne__(self, other: SigChunk, /) -> bool: ...

    def __getattr__(self, name: str, /) -> Incomplete: ...

class SigBit:
    wire: Wire
    data: State
    offset: int

    @overload
    def __init__(self, /) -> None: ...
    @overload
    def __init__(self, bit: State | bool, /) -> None: ...
    @overload
    def __init__(self, wire: Wire, offset: int = ..., /) -> None: ...
    @overload
    def __init__(self, chunk: SigChunk, index: int = ..., /) -> None: ...
    @overload
    def __init__(self, sig: SigSpec, /) -> None: ...
    @overload
    def __init__(self, sigbit: SigBit, /) -> None: ...

    def is_wire(self, /) -> bool: ...

    def __lt__(self, other: SigBit, /) -> bool: ...
    def __eq__(self, other: SigBit, /) -> bool: ...
    def __ne__(self, other: SigBit, /) -> bool: ...
    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def __getattr__(self, name: str, /) -> Incomplete: ...

class SigSpec:
    @overload
    def __init__(self, /) -> None: ...
    @overload
    def __init__(self, value: Const, /) -> None: ...
    @overload
    def __init__(self, chunk: SigChunk, /) -> None: ...
    @overload
    def __init__(self, wire: Wire, offset: int = ..., width: int = 1, /) -> None: ...
    @overload
    def __init__(self, str: str, /) -> None: ...
    @overload
    def __init__(self, val: int, width: int = 32, /) -> None: ...
    @overload
    def __init__(self, bit: State | SigBit, width: int = 1, /) -> None: ...
    @overload
    def __init__(self, chunks: list[SigChunk], /) -> None: ...
    @overload
    def __init__(self, bits: list[SigBit], /) -> None: ...
    @overload
    def __init__(self, bit: bool, /) -> None: ...

    def get_hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def chunks(self, /) -> list[SigChunk]: ...
    def bits(self, /) -> list[SigBit]: ...

    def size(self, /) -> int: ...
    def empty(self, /) -> bool: ...

    def __getitem__(self, index: int, /) -> SigBit: ...

    def sort(self, /) -> None: ...
    def sort_and_unify(self, /) -> None: ...

    @overload
    def replace(self, pattern: SigSpec, with_: SigSpec, other: SigSpec = ..., /) -> None: ...
    @overload
    def replace(self, rules: dict[SigBit, SigBit], other: SigSpec = ..., /) -> None: ...
    @overload
    def replace(self, offset: int, with_: SigSpec, /) -> None: ...

    @overload
    def remove(self, pattern: SigSpec | list[SigBit], other: SigSpec = ..., /) -> None: ...
    @overload
    def remove(self, offset: int, length: int = 1, /) -> None: ...

    def remove2(self, pattern: SigSpec, other: SigSpec, /) -> None: ...

    def remove_const(self, /) -> None: ...

    @overload
    def extract(self, pattern: SigSpec | list[SigBit], other: SigSpec, /) -> SigSpec: ...
    @overload
    def extract(self, offset: int, length: int = 1, /) -> SigSpec: ...
    def extract_end(self, offset: int, /) -> SigSpec: ...

    def lsb(self, /) -> SigBit: ...
    def msb(self, /) -> SigBit: ...

    def append(self, arg: SigSpec | Wire | SigChunk | Const | SigBit | State | bool, /) -> None: ...

    def extend_u0(self, width: int, is_signed: bool = False, /) -> None: ...

    def repeat(self, num: int, /) -> SigSpec: ...

    def reverse(self, /) -> None: ...

    def __lt__(self, other: SigSpec, /) -> bool: ...
    def __eq__(self, other: SigSpec, /) -> bool: ...
    def __ne__(self, other: SigSpec, /) -> bool: ...

    def is_wire(self, /) -> bool: ...
    def is_chunk(self, /) -> bool: ...
    def is_bit(self, /) -> bool: ...

    def is_fully_const(self, /) -> bool: ...
    def is_fully_zero(self, /) -> bool: ...
    def is_fully_ones(self, /) -> bool: ...
    def is_fully_def(self, /) -> bool: ...
    def is_fully_undef(self, /) -> bool: ...
    def has_const(self, /) -> bool: ...
    def has_marked_bits(self, /) -> bool: ...
    def is_onehot(self, pos=None, /) -> bool: ...

    def as_bool(self, /) -> bool: ...
    def as_int(self, is_signed: bool = False, /) -> int: ...
    def as_string(self, /) -> str: ...
    def as_const(self, /) -> Const: ...
    def as_wire(self, /) -> Wire: ...
    def as_chunk(self, /) -> SigChunk: ...
    def as_bit(self, /) -> SigBit: ...

    def match(self, pattern: str, /) -> bool: ...

    def to_sigbit_set(self, /) -> list[SigBit]: ...
    def to_sigbit_pool(self, /) -> list[SigBit]: ...
    def to_sigbit_vector(self, /) -> list[SigBit]: ...
    def to_sigbit_map(self, other: SigSpec, /) -> dict[SigBit, SigBit]: ...
    def to_sigbit_dict(self, other: SigSpec, /) -> dict[SigBit, SigBit]: ...

    @staticmethod
    def parse(sig: SigSpec, module: Module, str: str, /) -> bool: ...
    @staticmethod
    def parse_sel(sig: SigSpec, design: Design, module: Module, str: str, /) -> bool: ...
    @staticmethod
    def parse_rhs(lhs: SigSpec, sig: SigSpec, module: Module, str: str, /) -> bool: ...

    def at(self, offset: int, defval: SigBit, /) -> SigBit: ...

    def hash(self, /) -> int: ...

    def check(self, mod: Module, /) -> None: ...

    def __getattr__(self, name: str, /) -> Incomplete: ...

class Selection:
    full_selection: bool
    selected_modules: list[IdString]
    selected_members: dict[IdString, list[IdString]]

    def __init__(self, full: bool, /) -> None: ...

    def selected_module(self, mod_name: IdString, /) -> bool: ...
    def selected_whole_module(self, mod_name: IdString, /) -> bool: ...
    def selected_member(self, mod_name: IdString, memb_name: IdString, /) -> bool: ...
    def optimize(self, design: Design, /) -> None: ...

    def empty(self, /) -> bool: ...

class Monitor:
    hashidx_: int
    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def __init__(self, /) -> None: ...

    def __del__(self, /) -> None: ...
    def notify_module_add(self, arg: Module, /) -> None: ...
    def notify_module_del(self, arg: Module, /) -> None: ...
    @overload
    def notify_connect(self, arg1: Cell, arg2: IdString, arg3: SigSpec, arg4: SigSpec, /) -> None: ...
    @overload
    def notify_connect(self, arg1: Module, arg2: SigSig | list[SigSig], /) -> None: ...
    def notify_blackout(self, arg: Module, /) -> None: ...

class Design:
    hashidx_: int
    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    monitors: list[Monitor]
    scratchpad: dict[str, str]

    def bufNormalize(self, enable: bool = True, /) -> None: ...

    modules_: dict[IdString, Module]

    selection_stack: list[Selection]
    selection_vars: dict[IdString, Selection]
    selected_active_module: str

    def __init__(self, /) -> None: ...
    def __del__(self, /) -> None: ...

    def module(self, name: IdString, /) -> Module: ...
    def top_module(self, /) -> Module: ...

    def has(self, id: IdString, /) -> bool: ...

    def add(self, module: Module, /) -> None: ...

    def addModule(self, name: IdString, /) -> Module: ...
    def remove(self, module: Module, /) -> None: ...
    def rename(self, module: Module, new_name: IdString, /) -> None: ...

    def scratchpad_unset(self, varname: str, /) -> None: ...

    def scratchpad_set_int(self, varname: str, value: int, /) -> None: ...
    def scratchpad_set_bool(self, varname: str, value: bool, /) -> None: ...
    def scratchpad_set_string(self, varname: str, value: str, /) -> None: ...

    def scratchpad_get_int(self, varname: str, default_value: int = 0, /) -> int: ...
    def scratchpad_get_bool(self, varname: str, default_value: bool = False, /) -> bool: ...
    def scratchpad_get_string(self, varname: str, default_value: str = '', /) -> str: ...

    def sort(self, /) -> None: ...
    def check(self, /) -> None: ...
    def optimize(self, /) -> None: ...

    def selected_module(self, mod_name: IdString | Module, /) -> bool: ...
    def selected_whole_module(self, mod_name: IdString | Module, /) -> bool: ...
    def selected_member(self, mod_name: IdString, memb_name: IdString, /) -> bool: ...

    def selection(self, /) -> Selection: ...

    def full_selection(self, /) -> bool: ...

    def selected_modules(self, /) -> list[Module]: ...
    def selected_whole_modules(self, /) -> list[Module]: ...
    def selected_whole_modules_warn(self, include_wb: bool = False, /) -> list[Module]: ...
    @staticmethod
    def get_all_designs() -> dict[int, Design]: ...

_T = TypeVar('_T')

class idict(dict, Generic[_T]):
    @overload
    def __getitem__(self, key: _T) -> int: ...
    @overload
    def __getitem__(self, key: int) -> _T: ...

class Module(AttrObject):
    hashidx_: int
    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def add(self, arg: Wire | Cell | Process, /) -> None: ...

    design: Design
    monitors: list[Monitor]

    wires_: dict[IdString, Wire]
    cells_: dict[IdString, Cell]

    connections_: list[SigSig]

    name: IdString
    avail_parameters: idict[IdString]
    parameter_default_values: dict[IdString, Const]
    memories: dict[IdString, Memory]
    processes: dict[IdString, Process]

    def __init__(self, /) -> None: ...
    def __del__(self, /) -> None: ...
    @overload
    def derive(self, design: Design, parameters: dict[IdString, Const], mayfail: bool = False, /) -> IdString: ...
    @overload
    def derive(self, design: Design, parameters: dict[IdString, Const], interfaces: dict[IdString, Module], modports: dict[IdString, IdString], mayfail: bool = False, /) -> IdString: ...
    def count_id(self, id: IdString, /) -> int: ...
    def expand_interfaces(self, design: Design, local_interfaces: dict[IdString, Module], /) -> None: ...
    def reprocess_if_necessary(self, design: Design, /) -> bool: ...

    def sort(self, /) -> None: ...
    def check(self, /) -> None: ...
    def optimize(self, /) -> None: ...
    def makeblackbox(self, /) -> None: ...

    @overload
    def connect(self, conn: SigSig, /) -> None: ...
    @overload
    def connect(self, lhs: SigSpec, rhs: SigSpec, /) -> None: ...
    def new_connections(self, new_conn: list[SigSig], /) -> None: ...
    def connections(self, /) -> list[SigSig]: ...

    ports: list[IdString]
    def fixup_ports(self, /) -> None: ...

    bufNormQueue: list[tuple[Cell, IdString]]
    def bufNormalize(self, /) -> None: ...

    def cloneInto(self, new_mod: Module, /) -> None: ...
    def clone(self, /) -> Module: ...

    def has_memories(self, /) -> bool: ...
    def has_processes(self, /) -> bool: ...

    def has_memories_warn(self, /) -> bool: ...
    def has_processes_warn(self, /) -> bool: ...

    def selected_wires(self, /) -> list[Wire]: ...
    def selected_cells(self, /) -> list[Cell]: ...

    def wire(self, id: IdString, /) -> Wire: ...
    def cell(self, id: IdString, /) -> Cell: ...

    def remove(self, arg: list[Wire] | Cell | Process, /) -> None: ...

    def rename(self, arg: Wire | Cell | IdString, new_name: IdString, /) -> None: ...

    @overload
    def swap_names(self, w1: Wire, w2: Wire, /) -> None: ...
    @overload
    def swap_names(self, c1: Cell, c2: Cell, /) -> None: ...

    def uniquify(self, name: IdString, index: int = ..., /) -> IdString: ...

    def addWire(self, name: IdString, arg: int | Wire = 1, /) -> Wire: ...

    def addCell(self, name: IdString, arg: IdString | Cell, /) -> Cell: ...

    def addMemory(self, name: IdString, other: Memory) -> Memory: ...

    def addProcess(self, name: IdString, other: Process = ...) -> Process: ...

    @staticmethod
    def get_all_modules() -> dict[int, Module]: ...

class Wire(AttrObject):
    hashidx_: int
    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def __init__(self, /) -> None: ...
    def __del__(self, /) -> None: ...

    module: Module
    name: IdString
    width: int
    start_offset: int
    port_id: int
    port_input: bool
    port_output: bool
    upto: bool
    is_signed: bool

    def driverCell(self, /) -> Cell: ...
    def driverPort(self, /) -> IdString: ...

    @staticmethod
    def get_all_wires() -> dict[int, Wire]: ...

class Memory(AttrObject):
    hashidx_: int
    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def __init__(self, /) -> None: ...

    name: IdString
    width: int
    start_offset: int
    size: int
    def __del__(self, /) -> None: ...
    @staticmethod
    def get_all_memorys() -> dict[int, Memory]: ...

class Cell(AttrObject):
    hashidx_: int
    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def __init__(self, /) -> None: ...
    def __del__(self, /) -> None: ...

    module: Module
    name: IdString
    type: IdString
    connections_: dict[IdString, SigSpec]
    parameters: dict[IdString, Const]

    def hasPort(self, portname: IdString, /) -> bool: ...
    def unsetPort(self, portname: IdString, /) -> None: ...
    def setPort(self, portname: IdString, signal: SigSpec, /) -> None: ...
    def getPort(self, portname: IdString, /) -> SigSpec: ...
    def connections(self, /) -> dict[IdString, SigSpec]: ...

    def known(self, /) -> bool: ...
    def input(self, portname: IdString, /) -> bool: ...
    def output(self, portname: IdString, /) -> bool: ...

    def hasParam(self, paramname: IdString, /) -> bool: ...
    def unsetParam(self, paramname: IdString, /) -> None: ...
    def setParam(self, paramname: IdString, value: Const, /) -> None: ...
    def getParam(self, paramname: IdString, /) -> Const: ...

    def sort(self, /) -> None: ...
    def check(self, /) -> None: ...
    def fixup_parameters(self, set_a_signed: bool = False, set_b_signed: bool = False, /) -> None: ...

    def has_keep_attr(self, /) -> bool: ...

    @staticmethod
    def get_all_cells() -> dict[int, Cell]: ...

    def has_memid(self, /) -> bool: ...
    def is_mem_cell(self, /) -> bool: ...

class CaseRule(AttrObject):
    compare: list[SigSpec]
    actions: list[SigSig]
    switches: list[SwitchRule]

    def __del__(self, /) -> None: ...

    def empty(self, /) -> bool: ...

    def clone(self, /) -> CaseRule: ...

class SwitchRule(AttrObject):
    signal: SigSpec
    cases: list[CaseRule]

    def __del__(self, /) -> None: ...

    def empty(self, /) -> bool: ...

    def clone(self, /) -> SwitchRule: ...

class MemWriteAction(AttrObject):
    memid: IdString
    address: SigSpec
    data: SigSpec
    enable: SigSpec
    priority_mask: Const

class SyncRule:
    type: SyncType
    signal: SigSpec
    actions: list[SigSig]
    mem_write_actions: list[MemWriteAction]

    def clone(self, /) -> SyncRule: ...

class Process(AttrObject):
    hashidx_: int
    def hash(self, /) -> int: ...
    def __hash__(self, /) -> int: ...

    def __init__(self, /) -> None: ...
    def __del__(self, /) -> None: ...

    name: IdString
    module: Module
    root_case: CaseRule
    syncs: list[SyncRule]

    def clone(self, /) -> Process: ...

def run_pass(command: str, design: Design) -> None: ...
